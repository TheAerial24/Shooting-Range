<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Outdoor Precision Range - Tactical Update</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Inter', sans-serif; 
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; color: white;
            z-index: 80;
        }

        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 30px; height: 30px;
            /* Center the tip of the chevron exactly at 50/50 */
            transform: translate(-50%, 0%); 
            pointer-events: none;
        }
        #crosshair svg {
            width: 50%; height: 100%;
            fill: none;
            stroke: #00ff96;
            stroke-width: 2.5;
            filter: drop-shadow(0 0 3px rgba(0,255,150,0.6));
        }

        #scope-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 25%, black 40%, black 100%);
            display: none;
            z-index: 70;
            pointer-events: none;
        }
        
        #scope-reticle {
            position: absolute;
            top: 50%; left: 50%;
            width: 100%; height: 100%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 71;
            pointer-events: none;
        }
        .reticle-line-v { position: absolute; top: 0; left: 50%; width: 1px; height: 100%; background: rgba(255, 0, 0, 0.7); transform: translateX(-50%); }
        .reticle-line-h { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: rgba(255, 0, 0, 0.7); transform: translateY(-50%); }
        .reticle-dot { position: absolute; top: 50%; left: 50%; width: 3px; height: 3px; background: red; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 6px red; }

        #nvg-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 255, 100, 0.1);
            mix-blend-mode: screen;
            display: none;
            z-index: 65;
            pointer-events: none;
            box-shadow: inset 0 0 200px rgba(0, 50, 0, 0.8);
        }
        #nvg-grain {
            position: absolute;
            inset: 0;
            background: url('https://grainy-gradients.vercel.app/noise.svg');
            opacity: 0.15;
            pointer-events: none;
            display: none;
            z-index: 66;
        }

        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #0f172a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white; text-align: center;
            pointer-events: auto;
        }

        .hud-card {
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 12px;
        }

        #ballistics-hud {
            position: absolute;
            top: 20px; left: 20px;
            color: #fff;
            font-weight: 800;
            font-size: 10px;
            text-transform: uppercase;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #10b981;
        }

        #impact-hud {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 120px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #impact-hud.active { opacity: 1; }

        .target-silhouette-hud {
            width: 70px; height: 100px;
            background: #1e293b;
            position: relative; margin: 4px auto;
            border-radius: 8px 8px 2px 2px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .impact-dot {
            position: absolute;
            width: 4px; height: 4px;
            background: #ff4444; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px #ff0000;
        }

        #weapon-info {
            position: absolute;
            bottom: 20px; left: 20px;
            text-align: left;
        }

        #hit-notifier {
            position: absolute;
            top: 45%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 900;
            color: #00ff96;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,150,0.5);
        }

        #lane-hud {
            position: absolute;
            top: 20px; right: 20px;
            font-weight: 900;
            color: #00ff96;
            text-transform: uppercase;
        }

        .nvg-active #ui-layer { color: #00ff96; }
        .nvg-active #ballistics-hud { color: #00ff96; background: rgba(0,255,0,0.1); }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="start-overlay">
        <h1 class="text-4xl font-black mb-4 uppercase italic text-emerald-400">Precision Range</h1>
        <p class="mb-2 opacity-80 font-bold italic">SPACEBAR TO FIRE</p>
        <p class="mb-6 opacity-60 text-sm">Drag to Aim • A/D to Switch Lanes • Shift to Scope • N for Night Vision • R to Reload • 1-9 to Swap</p>
        <button id="start-btn" class="px-10 py-4 bg-emerald-600 text-white font-bold rounded-full hover:bg-emerald-500 shadow-lg transition-all active:scale-95">
            START SESSION
        </button>
    </div>

    <div id="nvg-overlay"></div>
    <div id="nvg-grain"></div>
    <div id="scope-overlay"></div>
    <div id="scope-reticle">
        <div class="reticle-line-v"></div>
        <div class="reticle-line-h"></div>
        <div class="reticle-dot"></div>
    </div>

    <div id="ui-layer">
        <div id="ballistics-hud">
            V_MUZZLE: <span id="v-muzzle">0</span> m/s<br>
            TIME: <span id="day-time">12:00</span>
        </div>

        <div id="lane-hud" class="hud-card">
            <span class="text-xs opacity-60">Lane</span><br>
            <span id="lane-display" class="text-xl">5</span>
        </div>

        <div id="crosshair">
            <svg viewBox="0 0 24 24">
                <!-- Upside down chevron: Center tip is at [12, 0] in SVG space -->
                <path d="M4 12 L12 2 L20 12" stroke-linecap="square"/>
            </svg>
        </div>
        <div id="hit-notifier">HIT</div>
        
        <div id="impact-hud" class="hud-card">
            <div class="target-silhouette-hud">
                <div id="impact-container" style="position: absolute; inset: 0;"></div>
            </div>
            <div class="text-[10px] font-black text-center text-emerald-400 mt-1 uppercase">Impact Log</div>
        </div>

        <div id="weapon-info" class="hud-card min-w-[140px]">
            <div id="weapon-name" class="text-sm font-black text-emerald-400 uppercase mb-1">...</div>
            <div class="flex justify-start gap-1 items-baseline">
                <span id="ammo-count" class="text-3xl font-black">0</span>
                <span id="ammo-max" class="text-xs text-white/40">/ 0</span>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, clock;
        let yawObject = new THREE.Object3D();
        let pitchObject = new THREE.Object3D();
        let gameStarted = false, isZoomed = false, isReloading = false, isNvg = false;
        
        const targets = []; 
        const weaponGroup = new THREE.Group();
        const particles = [];
        const physicalBullets = [];
        let currentWeaponIndex = 1;
        let spacePressed = false;
        let hasFiredThisPress = false; 
        let fireCooldown = 0;
        
        let lastShotTime = 0;
        const HUD_FADE_DELAY = 4000;

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Environment state - starts at 12:00 PM (0.5 cycle)
        let currentLane = 4;
        const laneSpacing = 6;
        let targetX = 0;
        let dayCycle = 0.5; 
        const CYCLE_DURATION = 10 * 60; // 10 minutes for full day/night cycle
        let sunLight, hemiLight;

        const weaponData = {
            1: { name: "M4 Carbine", color: 0x2d3748, spread: 0.002, zoom: 35, pos: [0.22, -0.25, -0.4], aimPos: [0, -0.22, -0.3], ammo: 30, velocity: 880, auto: true, caliber: 2.2 },
            2: { name: "AK-47", color: 0x3d2b1f, spread: 0.005, zoom: 35, pos: [0.22, -0.25, -0.4], aimPos: [0, -0.22, -0.3], ammo: 30, velocity: 715, auto: true, caliber: 2.4 },
            3: { name: "Vector", color: 0x1a1a1a, spread: 0.008, zoom: 40, pos: [0.18, -0.2, -0.3], aimPos: [0, -0.18, -0.25], ammo: 25, velocity: 380, auto: true, caliber: 1.8 },
            4: { name: "SPAS-12", color: 0x2d3748, spread: 0.035, zoom: 45, pos: [0.22, -0.25, -0.5], aimPos: [0, -0.24, -0.35], ammo: 8, velocity: 400, pellets: 8, auto: false, caliber: 2.0 },
            5: { name: "Double Barrel", color: 0x5c4033, spread: 0.05, zoom: 45, pos: [0.22, -0.25, -0.5], aimPos: [0, -0.24, -0.35], ammo: 2, velocity: 360, pellets: 12, auto: false, caliber: 2.8 },
            6: { name: "M1 Garand", color: 0x4a3728, spread: 0.001, zoom: 30, pos: [0.22, -0.25, -0.6], aimPos: [0, -0.24, -0.45], ammo: 8, velocity: 853, auto: false, caliber: 2.6 },
            7: { name: "Kar-98k", color: 0x3d2b1f, spread: 0.0004, zoom: 15, pos: [0.22, -0.25, -0.6], aimPos: [0, -0.48, -0.2], ammo: 5, velocity: 760, scope: true, auto: false, caliber: 3.2 },
            8: { name: "Barret M82", color: 0x0f172a, spread: 0.0001, zoom: 8, pos: [0.25, -0.28, -0.8], aimPos: [0, -0.52, -0.2], ammo: 10, velocity: 853, scope: true, auto: false, caliber: 4.8 },
            9: { name: "Anti-Tank", color: 0x111111, spread: 0.0, zoom: 5, pos: [0.3, -0.35, -1.2], aimPos: [0, -0.58, -0.2], ammo: 1, velocity: 1100, scope: true, auto: false, caliber: 10.0 }
        };

        let currentAmmo = 30;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); 
            scene.fog = new THREE.Fog(0x87ceeb, 100, 1500);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 5000);
            pitchObject.add(camera);
            yawObject.add(pitchObject);
            yawObject.position.set(0, 1.7, 0);
            scene.add(yawObject);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);

            createWorld();
            switchWeapon(1);
            setupControls();
            animate();
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createWorld() {
            // Ground
            const grassGeo = new THREE.PlaneGeometry(10000, 10000);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x1b4332 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.receiveShadow = true;
            scene.add(grass);

            // Lanes
            const laneGeo = new THREE.PlaneGeometry(3, 5000);
            const laneMat = new THREE.MeshStandardMaterial({ color: 0x2d1b0f });
            
            const engagingDistances = [50, 75, 100, 150, 200, 250, 350, 500, 750];

            for (let i = 0; i < 9; i++) {
                const lane = new THREE.Mesh(laneGeo, laneMat);
                lane.rotation.x = -Math.PI / 2;
                lane.position.set((i - 4) * laneSpacing, 0.02, -2500);
                lane.receiveShadow = true;
                scene.add(lane);

                const distance = engagingDistances[i];
                spawnSteelTarget((i - 4) * laneSpacing, distance);
            }
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 256, 128);
            ctx.font = 'bold 80px Inter, sans-serif';
            ctx.fillStyle = '#00ff96';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text + 'm', 128, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function spawnSteelTarget(x, z) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            shape.moveTo(-0.25, 0); shape.lineTo(0.25, 0); shape.lineTo(0.25, 0.6); 
            shape.lineTo(0.15, 0.85); shape.lineTo(0.15, 0.95);
            shape.lineTo(-0.15, 0.95); shape.lineTo(-0.15, 0.85); shape.lineTo(-0.25, 0.6);
            
            const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: false });
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x475569, 
                metalness: 0.8, 
                roughness: 0.4,
                emissive: 0x00ff00,
                emissiveIntensity: 0
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = 1.0;
            mesh.castShadow = true;
            mesh.name = "TargetPlate";
            group.add(mesh);
            targets.push(mesh);
            
            const standGeo = new THREE.BoxGeometry(0.1, 1.0, 0.1);
            const standMat = new THREE.MeshStandardMaterial({ color: 0x0f172a });
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.y = 0.5;
            group.add(stand);

            const textTex = createTextTexture(z.toString());
            const markerPlaneGeo = new THREE.PlaneGeometry(1.2, 0.6);
            const markerPlaneMat = new THREE.MeshBasicMaterial({ map: textTex, transparent: true, side: THREE.DoubleSide });
            const markerPlane = new THREE.Mesh(markerPlaneGeo, markerPlaneMat);
            markerPlane.position.set(0, 0.4, 0.2);
            group.add(markerPlane);

            group.position.set(x, 0, -z);
            scene.add(group);
        }

        function setupControls() {
            document.getElementById('start-btn').addEventListener('click', () => {
                gameStarted = true;
                document.getElementById('start-overlay').style.display = 'none';
                document.body.requestPointerLock?.();
            });

            const onStart = (e) => {
                if (!gameStarted) return;
                isDragging = true;
                lastMouseX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                lastMouseY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
            };
            const onEnd = () => { isDragging = false; };
            const onMove = (e) => {
                if (!gameStarted) return;
                
                let dx, dy;
                if (document.pointerLockElement) {
                    dx = e.movementX || 0;
                    dy = e.movementY || 0;
                } else if (isDragging) {
                    const cx = e.clientX || (e.touches ? e.touches[0].clientX : lastMouseX);
                    const cy = e.clientY || (e.touches ? e.touches[0].clientY : lastMouseY);
                    dx = cx - lastMouseX;
                    dy = cy - lastMouseY;
                    lastMouseX = cx;
                    lastMouseY = cy;
                } else return;

                const sens = isZoomed ? 0.0004 : 0.002;
                yawObject.rotation.y -= dx * sens;
                pitchObject.rotation.x -= dy * sens;
                pitchObject.rotation.x = Math.max(-1.4, Math.min(1.4, pitchObject.rotation.x));
            };

            window.addEventListener('mousedown', onStart);
            window.addEventListener('touchstart', onStart, { passive: false });
            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchend', onEnd);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, { passive: false });

            window.addEventListener('keydown', (e) => {
                if(!gameStarted) return;
                if(e.code === 'Space') spacePressed = true;
                if(e.code === 'KeyR') reload();
                if(e.code === 'KeyN') toggleNvg();
                if(e.shiftKey) { isZoomed = true; updateUI(); }
                if(e.key >= '1' && e.key <= '9') switchWeapon(parseInt(e.key));
                
                if(e.code === 'KeyA') {
                    currentLane = Math.max(0, currentLane - 1);
                    targetX = (currentLane - 4) * laneSpacing;
                    document.getElementById('lane-display').innerText = currentLane + 1;
                }
                if(e.code === 'KeyD') {
                    currentLane = Math.min(8, currentLane + 1);
                    targetX = (currentLane - 4) * laneSpacing;
                    document.getElementById('lane-display').innerText = currentLane + 1;
                }
            });

            window.addEventListener('keyup', (e) => {
                if(e.code === 'Space') { spacePressed = false; hasFiredThisPress = false; }
                if(!e.shiftKey) { isZoomed = false; updateUI(); }
            });
        }

        function toggleNvg() {
            isNvg = !isNvg;
            document.getElementById('nvg-overlay').style.display = isNvg ? 'block' : 'none';
            document.getElementById('nvg-grain').style.display = isNvg ? 'block' : 'none';
            document.body.classList.toggle('nvg-active', isNvg);
            
            targets.forEach(t => {
                t.material.emissiveIntensity = isNvg ? 1.0 : 0;
            });
        }

        function switchWeapon(id) {
            currentWeaponIndex = id;
            const d = weaponData[id];
            currentAmmo = d.ammo;
            isZoomed = false;
            hasFiredThisPress = false;
            updateUI();
            
            while(weaponGroup.children.length > 0) weaponGroup.remove(weaponGroup.children[0]);
            const mat = new THREE.MeshStandardMaterial({ color: d.color, metalness: 0.8 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.6), mat);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.5), new THREE.MeshStandardMaterial({color:0x000000}));
            barrel.rotation.x = Math.PI/2; barrel.position.z = -0.4;
            weaponGroup.add(body, barrel);
            weaponGroup.position.set(...d.pos);
            pitchObject.add(weaponGroup);
            
            document.getElementById('v-muzzle').innerText = d.velocity;
        }

        function updateUI() {
            const data = weaponData[currentWeaponIndex];
            document.getElementById('weapon-name').innerText = data.name;
            document.getElementById('ammo-count').innerText = currentAmmo;
            document.getElementById('ammo-max').innerText = `/ ${data.ammo}`;
            
            const cross = document.getElementById('crosshair');
            const scope = document.getElementById('scope-overlay');
            const reticle = document.getElementById('scope-reticle');
            
            if(isZoomed && data.scope) {
                cross.style.display = 'none'; scope.style.display = 'block'; reticle.style.display = 'block';
            } else {
                cross.style.display = 'block'; scope.style.display = 'none'; reticle.style.display = 'none';
            }
        }

        function reload() {
            if(isReloading || currentAmmo === weaponData[currentWeaponIndex].ammo) return;
            isReloading = true;
            setTimeout(() => {
                currentAmmo = weaponData[currentWeaponIndex].ammo;
                isReloading = false;
                updateUI();
            }, 1000);
        }

        function createSpark(pos, caliberScale = 1.0) {
            const color = isNvg ? 0x00ff00 : 0xffaa00;
            const impactLight = new THREE.PointLight(color, 8 * caliberScale, 6 * caliberScale);
            impactLight.position.copy(pos).add(new THREE.Vector3(0, 0, 0.1));
            scene.add(impactLight);
            
            let lightLife = 0.2;
            const count = Math.min(100, 25 + (15 * caliberScale));
            for(let i=0; i < count; i++) {
                const s = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02 * caliberScale, 0.02 * caliberScale, 0.02 * caliberScale),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                s.position.copy(pos);
                const vel = new THREE.Vector3(
                    (Math.random()-0.5) * 0.5 * caliberScale, 
                    (Math.random()) * 0.5 * caliberScale, 
                    (Math.random()-0.5) * 0.5 * caliberScale
                );
                particles.push({ mesh: s, vel, life: 0.6 + (0.4 * caliberScale) });
                scene.add(s);
            }

            const animateLight = () => {
                lightLife -= 0.02;
                impactLight.intensity = Math.max(0, lightLife * 120 * caliberScale);
                if(lightLife > 0) requestAnimationFrame(animateLight);
                else scene.remove(impactLight);
            };
            animateLight();
        }

        function fire() {
            if(currentAmmo <= 0 || isReloading) { reload(); return; }
            const d = weaponData[currentWeaponIndex];
            if(!d.auto && hasFiredThisPress) return;
            hasFiredThisPress = true;

            currentAmmo--;
            lastShotTime = Date.now();
            updateUI();
            
            const spawnPos = new THREE.Vector3();
            weaponGroup.getWorldPosition(spawnPos);
            
            const cameraDir = new THREE.Vector3(0, 0, -1);
            cameraDir.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));

            const pelletCount = d.pellets || 1;
            for(let i = 0; i < pelletCount; i++) {
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.025), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.9}));
                bullet.position.copy(spawnPos);
                
                const dir = cameraDir.clone();
                const spread = isZoomed ? d.spread * 0.05 : d.spread;
                dir.x += (Math.random()-0.5) * spread;
                dir.y += (Math.random()-0.5) * spread;

                scene.add(bullet);
                physicalBullets.push({
                    mesh: bullet, 
                    vel: dir.multiplyScalar(d.velocity * 0.02),
                    gravity: 0.0005, 
                    life: 12.0, 
                    caliber: d.caliber, 
                    lastPos: spawnPos.clone()
                });
            }
            weaponGroup.position.z += 0.08;
            pitchObject.rotation.x += 0.003;
        }

        function addImpactToHUD(obj, point) {
            const container = document.getElementById('impact-container');
            const hud = document.getElementById('impact-hud');
            const notifier = document.getElementById('hit-notifier');
            hud.classList.add('active');
            notifier.style.opacity = '1';
            setTimeout(() => notifier.style.opacity = '0', 200);
            
            const dot = document.createElement('div');
            dot.className = 'impact-dot';
            const local = obj.worldToLocal(point.clone());
            const xPercent = ((local.x + 0.25) / 0.5) * 100;
            const yPercent = (1 - (local.y / 0.95)) * 100;
            dot.style.left = `${xPercent}%`;
            dot.style.top = `${yPercent}%`;
            container.appendChild(dot);
            setTimeout(() => {
                dot.style.transition = 'opacity 1s ease';
                dot.style.opacity = '0';
                setTimeout(() => dot.remove(), 1000);
            }, 3000);
        }

        function updateEnvironment(dt) {
            dayCycle += dt / CYCLE_DURATION;
            if (dayCycle > 1) dayCycle -= 1;

            const sunAngle = dayCycle * Math.PI * 2 - Math.PI / 2;
            const sunY = Math.sin(sunAngle);
            const sunX = Math.cos(sunAngle);

            sunLight.position.set(sunX * 200, sunY * 200, 100);
            sunLight.intensity = Math.max(0, sunY * 1.5);
            
            const dayColor = new THREE.Color(0x87ceeb);
            const nightColor = new THREE.Color(0x020617);
            const sunsetColor = new THREE.Color(0xf97316);
            
            let skyColor;
            if (sunY > 0.2) skyColor = dayColor;
            else if (sunY > -0.2) skyColor = sunsetColor.clone().lerp(nightColor, Math.abs(sunY - 0.2) / 0.4);
            else skyColor = nightColor;

            scene.background = skyColor;
            scene.fog.color = skyColor;
            hemiLight.intensity = Math.max(0.05, sunY * 0.6);

            const hours = Math.floor(dayCycle * 24);
            const mins = Math.floor((dayCycle * 24 % 1) * 60);
            document.getElementById('day-time').innerText = `${hours.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const now = Date.now();
            
            if (gameStarted) {
                updateEnvironment(dt);

                yawObject.position.x += (targetX - yawObject.position.x) * 0.15;

                if (now - lastShotTime > HUD_FADE_DELAY) {
                    document.getElementById('impact-hud').classList.remove('active');
                }

                const d = weaponData[currentWeaponIndex];
                if(spacePressed && fireCooldown <= 0) {
                    fire();
                    fireCooldown = d.name === "Vector" ? 0.05 : 0.2;
                }
                if(fireCooldown > 0) fireCooldown -= dt;

                const targetPos = isZoomed ? d.aimPos : d.pos;
                weaponGroup.position.x += (targetPos[0] - weaponGroup.position.x) * 0.25;
                weaponGroup.position.y += (targetPos[1] - weaponGroup.position.y) * 0.25;
                weaponGroup.position.z += (targetPos[2] - weaponGroup.position.z) * 0.25;
                
                camera.fov += ((isZoomed ? d.zoom : 60) - camera.fov) * 0.25;
                camera.updateProjectionMatrix();

                for(let i=physicalBullets.length-1; i>=0; i--) {
                    const b = physicalBullets[i];
                    const moveVector = b.vel.clone();
                    const dist = moveVector.length();
                    const direction = moveVector.normalize();
                    
                    const ray = new THREE.Raycaster(b.lastPos, direction, 0, dist + 0.1);
                    const hits = ray.intersectObjects(targets);
                    if(hits.length > 0) {
                        createSpark(hits[0].point, b.caliber);
                        addImpactToHUD(hits[0].object, hits[0].point);
                        scene.remove(b.mesh); physicalBullets.splice(i, 1);
                        continue;
                    }
                    b.lastPos.copy(b.mesh.position);
                    b.mesh.position.add(b.vel);
                    b.vel.y -= b.gravity;
                    
                    if(b.mesh.position.y < -1 || b.life <= 0) { 
                        scene.remove(b.mesh); 
                        physicalBullets.splice(i, 1); 
                    }
                    b.life -= dt;
                }

                for(let i=particles.length-1; i>=0; i--) {
                    const p = particles[i];
                    p.mesh.position.add(p.vel);
                    p.vel.y -= 0.01; p.life -= dt;
                    p.mesh.scale.setScalar(p.life);
                    if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
                }
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
